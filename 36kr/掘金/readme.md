## 写在前面
在JS中，作用域(Scope)的知识一直是抽象并且难以理解的，笔者是一名刚刚毕业的前端小白，在学习作用域与作用域链的过程中也是饱受折磨，本文将尽可能地用通俗的话来解释作用域与作用域链，希望对在作用域中苦苦挣扎的小伙伴有所帮助，如果有理解错误或者不到位的地方也请指出，不胜感激~
## 编译原理
这篇文章明明是要讲作用域，为什么要先讲编译原理呢？相信我，理解了编译原理对于理解作用域有着莫大的帮助。

在传统的编译语言中，程序执行代码一般分为以下三个阶段：
- 分词/词法分析
- 解析/语法分析
- 代码生成
#### 词法分析
或者叫分词阶段，首先你得明白，浏览器是无法读懂你的代码的，它能读懂的只有二进制码，因此它只能将你的代码拆分。
举个栗子：
```js
    var a = 2;
```
浏览器是怎么执行的呢？浏览器会先将这段代码分解为一个个的词法单元：[var、a、=、2、；]。
#### 语法分析
语法分析的过程就是将**词法单元流**(也就是上一步最后得出的数组)转换成一个由元素逐级嵌套所组成的代表了程序语法解构的树，这个树被称为“抽象语法树(AST,Abstract Syntax Tree)”。(人话？？？)别慌，这里给大家推荐一个网站[Jointjs](https://resources.jointjs.com/demos/javascript-ast)，如图：
![](https://user-gold-cdn.xitu.io/2020/7/18/1735f72767508b51?w=574&h=376&f=png&s=8320)
这个网站可以将我们输入的代码转换成一棵抽象语法树(众所周知，程序员的树都是倒着长的...)，上图就是由“var a = 2;”所生成的抽象语法树，Program为整个程序的根节点，在他的下面就是VariableDeclaration(变量声明)，紧接着就是VariableDeclarator(变量说明符)，然后就将a和2作为它的两个子节点进行赋值。
#### 代码生成
这里我们不讲具体细节（我不会），简单的说就是将“var a = 2；”这行代码的AST转化为机器能运行的机器码。如图就是chrome的v8工作原理图：

![](https://user-gold-cdn.xitu.io/2020/7/18/1735f7e01de0fe5c?w=1142&h=522&f=jpeg&s=83492)

感兴趣的朋友们可以去看看李兵老师的《浏览器工作原理与实践》
## 什么是作用域
作用域是变量与函数的可访问范围，或者说限制其可用范围，作用域决定了代码区块中变量和其他资源的可见性，作用域的使用可有效提高程序逻辑的局部性，增强程序的可靠性，减少名字冲突。(人话？？？)

有没有一种每一个字都认识，但是连在一起就看不懂了...

举个栗子:
``` js
function fn (){
    var b = 0
    console.log(b) // 0
}
fn()
console.log(b) //b is not defined
```
从上面的例子可以体会到作用域的基本概念，变量b是在函数fn中的一个变量, 并没有在全局作用域中声明, 因此只能在fn的函数作用域中引用, 在全局作用域中引用则会报错。

换句话说: b住在fn小区, 如果你在fn小区里大喊一声:"b你给我出来!", 嗓门大一点他应该就听到然后出来了, 但是你在小区外面喊的话那就会有好心的路人来告诉你这儿没这个人 (error!)

在es6之前js中没有块级作用域的概念, 只有**全局作用域和函数作用域**, 而es6中新增的let和const则为我们了提供了"**块级作用域**"的概念。
### 1. 全局作用域和函数作用域
全局作用域顾名思义, 拥有全局作用域的对象可以从任何地方调用到, 可以理解为一个老好人, 你找他他就来了。

举个栗子:
``` JavaScript
    var a1 = 1; // 老好人1号
    function fn1 () {
        a2 = 2;  // 老好人2号
        var b1 = 11  // 我不是老好人 
        function fn2 () {
            window.a3 = 3 // 老好人3号
            function fn3 () {
                console.log(b1) // 11
            }
            fn3()
        }
        fn2()
    }
    fn1()
    fn2()  // fn2 is not defined
    console.log(a1) // 1
    console.log(a2) // 2
    console.log(a3) // 3
    console.log(b1) //b1 is not defined
```
在这个例子中的a1,a2,a3都可以在全局中访问到, 即使a2 a3 分别定义在了函数fn1 fn2中, 这也是定义全局变量的三种方法, 不过还是建议小伙伴们在编程的过程中尽量少定义全局变量, 因为在我们的项目中尤其是大型项目, 我们要定义的变量太多了, 全局变量太多的话就很容易产生变量名称冲突, 污染命名空间。

准确的说老好人2号并**不是一个全局变量**, 而是一个**全局变量的属性**, 他并不是一个声明操作, 而是一个赋值操作, 当执行到a2 = 2 时, 他会尝试在函数fn1中查找a2, 没找到则会一直沿着作用域链向上查找, 直到全局作用域, 全局作用域中依然没找到则会创建一个a2属性并赋值为2。如果要详细讲其中的区别的话所需要的篇幅太大了,感兴趣的小伙伴可以自行去了解。(等笔者理解透彻之后或许也会单独开一篇文章解释)

说回到这个例子中, 函数作用域是指声明在函数内部, 在函数内部才能访问到, 如b1和fn2,
他们在全局作用域中都无法访问到, 但是在 fn3 内部却可以查找到 b1,这是要查找一个变量的话, **是从函数内部向外查找的**, 如例子中的  'console.log(b1)' 的过程, 查找过程为: fn3 -> fn2 -> fn1,这也就是我们后面要聊到的作用域链了。
### 2.块级作用域
在es6之前是没有块级作用域这个概念的, 随着 es6 新增的 let 和 const 才引入了这个概念, 我们先简单的说一下let与const的区别, let声明的是一个**变量**, 而const声明的是一个**不可变的常量**(初步了解一下,本节例子中只采取let 和var进行比较)。

块级作用域可以在以下几种情况下创建:
- 函数内部
- {  }内部就是一个块级作用域
- for循环的条件中

我们先通过一个简单的例子来看一下 var 与 let 的区别:
``` js
{
    var a = 1
    let b = 2
}
console.log(a) // 1
console.log(b) // b is not defined
```
可以看出, var直接无视了{ }的限制, 从全局作用域中仍然可以调用, 而 let 所声明的 b 则很乖巧的待在了 { } 中。因为 **var 没有块级作用域的概念**, 它根本不认识 { }, 它唯一能理解的 { } 只有出现在函数声明中, 这里要注意: 很多小伙伴都知道var没有块级作用域的概念, 但是忽略了**var是有函数作用域的概念**这一点 , 我们对上面的例子进行一下小修改:
``` js
function fn () {
    var a = 1
}
console.log(a) // a is not defined
```
可以看到这样声明的话 var 还是被{ }老老实实的包了起来。

再来聊一聊for循环中的作用域, 老规矩, 举个栗子:
```js
    for(var i=0;i<5;i++){
        setTimeout(() => console.log(i),500)
    }
```
猜猜看输出结果是什么, 0 1 2 3 4 ? 天真! **var是没有块级作用域的** , 当500毫秒之后这个 for 循环早就执行结束了, 因此在输出的时候所查找到的都是同一个结束了所有循环的 i ,最终输出结果是 5 5 5 5 5。我们再来看看let:
```js
    for(let i=0;i<5;i++){
        setTimeout(() => console.log(i),500)
    }
```
这一段代码的输出结果才是大家所想的0 1 2 3 4, 因为没一次循环的 i 都会在一个独立的块级作用域中被输出, 而独立的块级作用域中的 i ,依然是那个循环的时候的 i。

### 3. 欺骗作用域
本节属于开阔视野，**强烈不推荐使用**(会导致性能下降)。

按照我们的理解，作用域在我们写代码的时候就已经决定了，那怎么会有“欺骗”这个说法呢？在JavaScript中有以下两种方法来实现：
#### eval
eval(...)函数接受一个字符串为参数，并将字符串中的内容视为书写在程序中的代码执行，换句话说，eval(...)所接受的参数将顶替eval(...)，成为程序中将要执行的代码。
举个栗子：
```js
    function fn (a,str){
        eval(str)
        console.log(a,b)  // 0 2
    }
    var b = 1
    fn(0,'b=2')
```
其中字符串'b=2'在eval(str)处执行，因此输出了"0 , 2"而不是"0 , 1"。
#### with
## 作用域链
## 变量提升


